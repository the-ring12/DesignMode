# 工厂方法模式

定义一个创建对象的接口，但是让子类决定将哪一个实例化。工厂方法模式让一个类的实例化延迟到其子类。

主要有 4 个角色：

- Product（抽象工厂）

  它是定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类

- ConcreteProduct（具体产品）

  它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。

- Factory（抽象工厂）

  在抽象工厂类中声明了工厂方法（Factory Method），用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。
- ConcreteFactory（具体工厂）

  他是抽象工厂的子类，实现了在抽象工厂中声明的工厂方法，宁可由客户端调用，返回一个具体产品类的实例。

> 某系统运行日志记录器（Logger）可以通过多种途径保存系统的运行日志，例如通过文件记录或数据库记录，用户可以通过修改配置文件灵活地更换日志记录方式。在设计各类日志记录器时，开发人员发现需要对日志记录器进行一些初始化工作，初始化参数地设置过程较为复杂，而且某些参数地设置有严格的先后次序，否则可能会发生记录失败。
>
> 为了更好的封装记录器的初始化过程并保证多种记录器切换的灵活性，现使用工厂方法模式设计该系统（注：<u>在 Java 中常用的日志记录工具有 SLF4J、Log4j、GCLogViewer、Logstash 等</u>）。

<img src="./Package%20factorymethod.png" alt="工厂方法模式">


**工厂方法模式的优点**

（1）在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。

（2）使用工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够让工厂自主确定创建何种产品对象，而如何创建这个对象的细节完全封装在具体工程内部。工厂方法模式之所以又被称为多态工厂模式，正是因为所有具体工厂类都具有同一抽象父类。

（3）使用工厂方法模式的另一个优点是在系统中加入新产品时无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只添加一个具体工厂和具体产品即可，这样系统的可扩展性也就变得非常好，完全符合**开闭原则**
。

**工厂方法模式的缺点**

（1）在添加新产品时需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。

（2）由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度。

**工厂方法模式适用场景**

（1）客户端不知道它所需要的对象的类。在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体产品对象由具体工厂类创建，可将具体工厂类的类名存储在配置文件或数据库中。

（2）抽象工厂类通过其子类来指定创建哪个对象。在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时子类对象将覆盖父类对象，从而使得系统更容易扩展。

#### Java 反射

Java 反射是指在程序运行时获取已知名称的类或已有对象相关信息的一种机制，包括类的方法、属性、父类等信息，还包括实例的创建和实例类型的判断等。

在反射中使用最多的类是 Class 类，Class 类的实例表示正在运行的 Java 应用程序中的类和接口，其 forName(String className) 方法还可以返回与带有给定字符串名的类或接口相关联的 Class 对象，再通过
Class 对象的 newInstance() 方法创建此对象所表示的类的一个新实例，即通过一个类名字符串得到类的实例。

#### 配置文件

软件系统的配置文件通常为 XML 文件，可以使用 DOM（Document Object Model）、SAX（Simple API for XML）、StAX（Streaming API for XML）等技术来处理 XML 文件。