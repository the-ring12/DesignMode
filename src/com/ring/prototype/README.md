# 原型模式

使用原型实例指定待创建对象的类型，并且通过复制这个原型类创建新的对象。

其有 3 个角色：

- Prototype（抽象原型类）

  它是声明克隆方法的接口，是所有具体原型类的公共父类，它可以是抽象类也可以是接口，甚至可以是具体实现类。

- ConcretePrototype（具体原型类）

  它实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象。

- Client（客户端）

  在客户类中，让一个原型对象克隆自身从而创建一个新的对象，只需要直接实例化或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法即可得到多个相同的对象。

根据在复制原型变量的同时是否复制包含在原型对象中引用类型的成员变量，原型模式的克隆机制分为两种，即浅克隆（Shallow Clone）和深克隆（Deep Clone）。

1. 浅克隆 在浅克隆中，如果原型对象的成员变量是值类型（如
   int、double、byte、boolean、char等基本数据类型），将复制一份给克隆对象；如果原型对象的成员变量是应用类型（如类、接口、数组等复杂数据类型），则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。简单来说，<u>
   在浅克隆中，当原型对象被复制时只复制它本身和其中包含的值类型的成员变量，而被引用类型的成员变量并没有被复制</u>。
2. 深克隆 在深克隆中，无论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象，深克隆将原型对象的所有引用对象页复制一份给克隆对象。简单来说，<u>在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将被复制</u>。

**Java 语言中的 clone() 方法和 Cloneable 接口**

在 Java 语言中，所有的 Java 类均继承自 java.lang.Object 类，Object 类提供了一个 clone() 方法，可以将一个 Java 对象复制一份。因此在 Java 中可以直接使用 Object 提供的
clone() 方法来实现对象的浅克隆。

需要注意的是能够实现克隆的 Java 类必须实现一个表示接口 Cloneable，表示这个 Java 类支持被复制。如果一个类没有实现这个接口但是调用了 clone() 方法，Java 编译将抛出一个
CloneNotSupportException 异常。

> 在使用某 OA 系统时，有些岗位的员工发现他们每周的工作都大同小异，因此在填写工作周报时很多内容都是重复的，为了提高工作周报的创建效率，大家迫切希望有一种机制能够快速创建相同或者相似的周报，包括创建周报的附件。
>
> 使用原型模式来对该 OA 系统进行改进。

1. 浅克隆

    <img src="./Package shallowclone.png" alt="浅克隆">
2. 深克隆

   在 Java
   语言中可以通过序列化（Serialization）等方式来实现深克隆。序列化就是将对象写到流的过程，写到流中的对象是原有对象的一个复制，而原对象仍然存于内存中。通过序列化实现的复制不仅可以复制对象本身，而且还可以复制其引用的成员变量，因此通过序列化将对象写到一个流中，再从流中将其读出来，可以实现深克隆。

    <img src="./Package%20deepclone.png" alt="深克隆">

**原型模式的优点**

（1）当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率。

（2）扩展性较好，由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，增加或减少产品类对原有系统没有任何影响。

（3）原型模式提供了简化的创建结构，工厂方法模式常常需要有一个与产品类等级结构相同的工厂等级结构，而原型模式就不需要这样，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品。

（4）可以使用深克隆的方式保存对象的状态，使用原型模式将对象复制一份且将其状态保存起来，以便在需要的时候使用（例如恢复到某一历史状态），可辅助实现撤销操作。

**原型模式的缺点**

（1）需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时需要修改源代码，违背了开闭原则。

（2）在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦。

**原型模式适用场景**

（1）创建新对象成本较大（例如初始化需要占用较长时间、占用太多的 CPU 资源或网络资源），新对象可以通过复制已有对象来获得，如果是相似对象，则可以对其成员变量稍加修改。

（2）系统要保存对象的状态，而对象的状态变化很小。

（3）需要避免使用分层次的工厂类来创建分层次对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新的实例更加方便。




