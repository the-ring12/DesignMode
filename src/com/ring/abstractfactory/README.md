# 抽象工厂模式

提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。

主要有 4 个角色：

- AbstractFactory（抽象工厂）

  它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。

- ConcreteFactory（具体工厂）

  它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成一个产品族，每一个产品都位于某个产品等级结构中。

- AbstractProduct（抽象产品）

  它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。

- ConcreteProduct（具体产品）

  它定义具体工厂方法的具体产品对象，实现抽象产品接口中声明的业务方法。

> 某软件公司要开发一套界面皮肤库，可以对基于 Java 的桌面软件进行界面优化。用户在使用时可以通过在但选择皮肤，不同的皮肤将提供视觉效果不同的按钮、文本框、组合框等界面元素，例如春天（Spring）风格的皮肤将提供浅绿色的按钮、绿色边框的文本框和绿色边框的组合框，而夏天（Summer）风格的皮肤则提供浅蓝色的按钮、蓝色边框的文本框和蓝色边框的组合框，其结构示意图如图所示
> ```mermaid
> graph LR;
> A[皮肤库] --- B[Spring 风格];
> A --- C[Summer 风格];
> B --- [浅绿色按钮];
> B --- [绿色边框文本框];
> B --- [绿色边框组合框];
> C --- [浅蓝色按钮];
> C --- [蓝色边框文本框];
> C --- [蓝色边框组合框];
> ```
>
> 该皮肤库需要具备良好的灵活性和可扩展性，用户可以自由选择不同的皮肤，开发人员可以在不修改既有代码的基础上增加新的皮肤。
>
> 使用抽象工厂模式来设计该界面皮肤库。

<img src="./Package%20abstractfactory.png" alt="抽象工厂模式">

**抽象工厂模式优点**

（1）抽象工厂模式隔离了具体类的生成，使得客户端并不需要知道什么被创建。由于这种隔离，更换一个具体的工厂变得相对容易，所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需要改变具体工厂的实例就可以在某种程度上改变整个软件系统的行为。

（2）当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。

（3）增加新的产品族很方便，无须修改已有系统，符合开闭原则。

**抽象工厂模式的缺点**

增加新的产品等级结构麻烦，需要对原有系统进行加大修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了开闭原则。

**抽象工厂模式使用场景**

（1）一个系统不应当依赖于产品类实例如恶化被创建、组合和表达的细节，这对于所有类型的工厂模式都是很重要的，用户无须关心对象的创建过程，将对象的创建和使用解耦。

（2）系统中有多余一个产品族，而每次只是用其中某一产品族。可以通过配置文件等方式来使用户能够动态地改变产品族，也可以很方便地增加新的产品族。

（3）属于同一产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。同一个产品族中的产品可以是没有任何关系的对象那个，但是它们都具有一些共同的约束，如同一操作系统下的按钮和文本框，按钮与文本框之间没有直接关系，但它们都属于某一操作系统的，此时具有一个共同的约束条件，即操作系统的类型。

（4）产品等级结构稳定，在设计完成之后不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。

